/*
 * Copyright 2003-2013 MarkLogic Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The SampleLoadTester class implements a stress tester for 
 * loading automatically generated data to the server.
 * The data are generated by templates and configuration file, using 
 * utilities.BaseTemplateParser class.
 * The loading process is inheritated from XccLoadTester.
 *
 * @author Changfei Chen
 * @version 1.0
 * @since 2015-10-26 
*/

package test.stress;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.util.Random;

import test.utilities.BaseTemplateParser;

import com.marklogic.xcc.Content;
import com.marklogic.xcc.ContentCreateOptions;
import com.marklogic.xcc.ContentFactory;
import com.marklogic.xcc.exceptions.RetryableXQueryException;
import com.marklogic.xcc.exceptions.ServerConnectionException;
import com.marklogic.xcc.exceptions.XQueryException;

public class SampleLoadTester extends XccLoadTester{

  protected SampleLoadTestData loadTestData = null;
  protected Random randNum = null;
  protected SampleCRUDTester crudTester = null;
  protected SampleQueryTester queryTester = null;

  /**
  * This is consturcted is used without any other tester.
  */
  public SampleLoadTester(ConnectionData connData, SampleLoadTestData loadData,
                          String threadName) {
    super(connData, loadData, threadName);
    loadTestData = loadData;
    randNum = new Random();
  }

  /**
  * This constructor is used with crud tester. 
  * eg. Initialize the class in SampleCRUDTester.  
  */
  public SampleLoadTester(ConnectionData connData, SampleLoadTestData loadData,
                          String threadName, SampleCRUDTester ct) {
    super(connData, loadData, threadName);
    crudTester = ct;
    sessions = crudTester.sessions;
    loadTestData = loadData;
    randNum = new Random();		
  }
  
  /**
  * THis constructor is used with query tester.
  * eg. Initialize the class in SampleQueryTester.
  */ 
  public SampleLoadTester(ConnectionData connData, SampleLoadTestData loadData,
                          String threadName, SampleQueryTester qt) {
    super(connData, loadData, threadName);
    queryTester = qt;
    sessions = queryTester.sessions;
    loadTestData = loadData;
    randNum = new Random();
  }
 
  /**
  * This method is used for updating numLoaded for crud tester 
  * which uses this load tester for data loading. 
  */
  protected void updateNumLoaded(int change) {
    numLoaded = numLoaded + change;
    if (crudTester != null) {
      crudTester.numLoaded = numLoaded;
    }
  }

  /**
  * This method is used for updating uniqueURI for crud tester
  * which uses this load tester for data loading.
  */
  protected void updateURI(){
    if (crudTester != null) {
      crudTester.uniqueURI = uniqueURI;
    }
  }

  /**
  * This method overwrote the loadContentFromDir method in the XccLoadTester.
  * Instead of loading the existing documents from the directory, it loads
  * the data generated by utilities.BaseTemplateParser class and load it.
  */
  protected void loadContentFromDir(boolean rollback) 
                 throws InterruptedException {
    File[] fileList = listFiles(loadTestData.getLoadDir());
    int curBatch = 0;
    int batchStart = 0;
    int retryCount = 0;
    String verificationQuery = "";

    int i = 0;
    while (i < fileList.length && alive) {
      boolean inserted = false;
      try {
        if (curBatch == 0) {
          beginTransaction();
          batchStart = i;
        }
	        
        ContentCreateOptions options = null;
        options = ContentCreateOptions.newXmlInstance();
        options.setFormatXml();
        String[] collections = { uniqueURI };
        updateURI();
        options.setCollections(collections);
        String curURI = uniqueURI + uriDelta + fileList[i].getName();
        String templateName = fileList[i].getName();

        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        String fullpath = loadTestData.getLoadDir() + File.separator +
                          fileList[i].getName();
        System.out.println("Input template file full path: " + fullpath);
        FileInputStream fis = new FileInputStream(fullpath);

        BaseTemplateParser parser = new BaseTemplateParser();

        parser.setFieldManager(loadTestData.fieldManager);
        parser.initialize();
        parser.parseTemplate(fis, baos);
        // clean this up explicitly to facilitate GC
        fis.close();
        fis = null;
        String tradeXml = baos.toString("UTF-8");
        // seeing if this will clean up the dangling zip streams
        parser.cleanup();

        ResultsLogEntry logEntry = null;

        for (SessionHolder s : sessions) {
          long startTime = System.currentTimeMillis();
        
          logEntry = new ResultsLogEntry("thread " + threadName + 
                                          " template " + templateName +
                                          " load_" + curURI);
          logEntry.startTimer();

          // THIS IS WHERE WE SEND THE DOCUMENT OVER
          Content content;
          content = ContentFactory.newContent(curURI, tradeXml,
                  options);
          //print out for debug
          //System.out.println("curURI: " + curURI);
          //System.out.println("options: " + options);
          //System.out.println("tradeXml: " + tradeXml);
          
          s.session.insertContent(content);

          logEntry.stopTimer();
          logEntry.setPassFail(true);
          ResultsLogger logger =
            StressManager.getResultsLogger(loadTestData.getLogFileName());
          logger.logResult(logEntry);

          long elapsed = System.currentTimeMillis() - startTime;
          if (elapsed > 60 * 1000) {
           System.out.println("Took too long to load (" 
                              + elapsed + "): " + curURI);
          }
          totalTime += elapsed;
        }
        inserted = true;

        // if the current batch size is equal to the desired batch size,
        // or if this is the last file in the directory commit or rollback
        if (++curBatch >= loadTestData.getBatchSize()
            || i + 1 == fileList.length) {
          if (!rollback) {
            commitTransaction();
            //numLoaded += curBatch;
            updateNumLoaded(curBatch);
            // verify all documents from this commit are loaded
            for (int pos = i; curBatch > 0; --pos) {
              --curBatch;
              verificationQuery = "fn:count(fn:doc('" + curURI + "'))";
              verifyLoaded(verificationQuery, 1, curURI);
            }
          } else {
            rollbackTransaction();
            // verify all documents gone b/c rollback
            for (int pos = i; curBatch > 0; --pos) {
              --curBatch;
            }
          }
          // current batch has been added to total so 0 it out
          curBatch = 0;
          retryCount = 0;
        }

        // throttles the work contributed by this thread
        sleepBetweenIterations();

        // check documents in db at interval
        // if multistmt have to check at batch end
        if (numLoaded % loadTestData.getCheckInterval() == 0 && curBatch == 0
            && !rollback) {
          verifyInterval();
        }

        ++i;
      } catch (RetryableXQueryException e) {
        try {
          rollbackTransaction();
        } catch (Exception Ei) {
        }
        curBatch = 0;
        if (++retryCount > 25) {
          System.out.println("Retries exhausted");
          e.printStackTrace();
          ++i;
          retryCount = 0;
        } else {
          System.out.println("Retrying: " + retryCount);
          i = batchStart;
          Thread.sleep(1000);
        }
      } catch (ServerConnectionException e) {
        ++retryCount;
        if (retryCount < 100) {
          System.out.println("Retry for ServerConnectionException: "
                             + e.getMessage() + " count:" + retryCount);
          if (inserted) {
            i++;
            curBatch = 0;
          }
          Thread.sleep(10000);
          continue;
        }
        e.printStackTrace();
        try {
          rollbackTransaction();
        } catch (Exception Ei) {
        }
        ++i;
        curBatch = 0;
        retryCount = 0;
        totalTime = 0;
        String error = "ERROR could not load URI : " + uniqueURI;
        System.err.println(error);
        System.exit(1);
      } catch (XQueryException e) {
        // retry for XDMP-FORESTNID
        ++retryCount;
        if (e.getCode().equals("XDMP-FORESTNID") && retryCount < 100) {
          System.out.println("Retry for XDMP-FORESTNID: " + retryCount);
          if (inserted) {
            i++;
            curBatch = 0;
          }
          continue;
        } else if (e.getCode().equals("XDMP-DATABASEDISABLED") 
                   && retryCount < 100) {
          System.out.println("Retry for XDMP-DATABASEDISABLED: " + retryCount);
          if (inserted) {
            i++;
            curBatch = 0;
          }
          Thread.sleep(5000);
          continue;
        } else if (e.getCode().equals("XDMP-MULTIROOT") && retryCount < 100) {
          System.out.println("JJAMES: Insert failed for XDMP-MULTIROOT: " +
                uniqueURI + ", " + retryCount);
          if (inserted) {
            i++;
            curBatch = 0;
          }
    else
    {
      // need to figure out how not to retry
      i++;
    }
          Thread.sleep(5000);
          continue;
        } else if (e.getCode().equals("XDMP-DOCSTARTTAGCHAR") 
                   && retryCount < 100) {
          System.out.println("JJAMES: Insert failed for XDMP-DOCSTARTTAGCHAR: "
              + uniqueURI + ", " + retryCount);
          if (inserted) {
            i++;
            curBatch = 0;
          }
    else
    {
      // need to figure out how not to retry
      i++;
    }
          Thread.sleep(5000);
          continue;
        } else if (e.getCode().equals("XDMP-DOCUNEOF") && retryCount < 100) {
          System.out.println("JJAMES: Insert failed for XDMP-DOCUNEOF: " +
                uniqueURI + ", " + retryCount);
          if (inserted) {
            i++;
            curBatch = 0;
          }
    else
    {
      // need to figure out how not to retry
            i++;
    }
          Thread.sleep(5000);
          continue;
        } else if (e.getCode().equals("XDMP-DOCUTF8SEQ") && retryCount < 100) {
          System.out.println("JJAMES: Insert failed for XDMP-DOCUTF8SEQ: " +
                uniqueURI + ", " + retryCount);
          if (inserted) {
            i++;
            curBatch = 0;
          }
    else
    {
      // need to figure out how not to retry
            i++;
    }
          Thread.sleep(5000);
      continue;
    }
        e.printStackTrace();
        try {
          rollbackTransaction();
        } catch (Exception Ei) {
        }
        ++i;
        curBatch = 0;
        retryCount = 0;
        totalTime = 0;
        String error = "ERROR could not load URI : " + uniqueURI;
        System.err.println(error);
        System.exit(1);
      } catch (Throwable e) {
        // need to do something about exceptions and multistmt
        e.printStackTrace();
        try {
          rollbackTransaction();
        } catch (Exception Ei) {
        }
        ++i;
        curBatch = 0;
        retryCount = 0;
        totalTime = 0;
        String error = "ERROR could not load URI : " + uniqueURI;
        System.err.println(error);
        System.exit(1);
      }
    }
}

}
